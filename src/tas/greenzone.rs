//! The greenzone is responsible for automatic management of savestates. Every frame, we save the
//! emulator's state and store it in the greenzone. When the user seeks and edits the movie, the
//! greenzone determines which state playback should resume from.
//!
//! The greenzone is implemented using btrees to map from a frame number to a state. Not all frames
//! are necessarily present in order to save memory; thus, `Greenzone::restore` returns the latest
//! available state *prior* to the target frame, as if the desired frame is missing from the
//! greenzone emulation can be started from an earlier point and played until the target frame is
//! reached.
//!
//! The greenzone stores two types of states: "full" savestates and "delta" savestates. A full
//! savestate is a libretro savestate compressed using DEFLATE. A delta savestate is created by
//! XORing the savestate against a "parent" savestate, and compressing the resulting difference
//! using DEFLATE. Delta savestates are used because they take significantly less memory: two
//! savesates taken from frames that are close in time will differ only slightly. (For Super
//! Metroid, a full savestate tends to take around 100-150KB compressed, whereas delta savestates
//! are around 3-10KB). For simplicity, a delta savestate **always** references the previous full
//! savestate -- they cannot reference earlier full savestates, or other delta savestates.
//!
//! As the emulator runs, each frame its state is stored in the greenzone as a full savestate,
//! until the memory usage exceeds a threshold (currently 500MB). At this point, we perform a
//! 'garbage-collecting' operation. Each frame is given a priority, low-priority full savestates
//! are downgraded to delta savestates, and low-priority delta savestates are discarded. The
//! priority is assigned such that states are kept throughout the entire duration of the movie (so
//! that the user can seek to any point of the movie without long catch-up periods) but more states
//! are kept closer to where the cursor is.
//!
//! The garbage-collection operation generates a significant amount of work: thousands of states
//! may need to be delta-compressed, and if any of *these* states had delta states depending on
//! them, those states must additionally be "re-parented" to point to a new full savestate (which
//! requries decompressing and recompressing several states). Additionally, simple operations like
//! running a single emulator frame and inserting a full savestate where there was none previously
//! where there was may generate a large number of reparent operations, due to the requirement that
//! a delta savestate should always reference the previous full savestate. These cause significant
//! bursts of work that would cause noticable hitches and stutters if they blocked the emulation
//! thread. Thus, **all greenzone write operations occur in a background thread.**
//!
//! When the emulation thread issues a greenzone write operation, the operation is placed in a
//! mailbox of pending operations, which is monitored by the background thread. The background
//! thread pops operations from the queue and applies them to the greenzone (which is protected by
//! a mutex). Whenever the background thread needs to perform a relatively long-running operation
//! like savestate compression or decompression, it releases the mutex so that the emulation thread
//! can continue to access the greenzone.
//!
//! Because the queue can grow fairly long, the greenzone btrees do not necessarily represent the
//! current state. Rather, the current state is the combination of the contents of the btrees + all
//! pending operations in the mailbox. Thus, functions that read from the greenzone must check the
//! mailbox to see if the contents are affected by any pending operations.
//!
//! Normally, the mailbox is never flushed completely: the background thread sleeps once the queue
//! size drops below a threshold (100 operations). This is an optimization, because it's common for
//! greenzone operations to be made redundant by later operations. For example, consider a
//! greenzone consisting of a full savestate followed by a large number of delta savestates. If
//! emulation is played back frame-by-frame, each delta savestate will in sequence be overwritten
//! by a full savestate generated by the emulator playback. This would cause each of the subsequent
//! delta savestates to be reparented repeatedly to maintain the invariant that a delta savestate
//! references the preceding parent savestate. But by maintaining a nonzero queue size, the
//! reparent operations can "look ahead" to see that the delta savestates to be reparented are
//! about to be overwritten, thus the reparent is unnecessary.

use std::{
    collections::{BTreeMap, VecDeque},
    sync::{mpsc, Arc, Mutex},
};

use crate::core::{DeltaSavestate, Savestate, SavestateRef};

/// The greenzone is responsible for automatic management of savestates.
/// This structure is the emulator-side handle to the greenzone.
pub struct Greenzone {
    /// The data structures storing the state of the greenzone. This is shared with the background
    /// worker thread.
    g: Arc<Mutex<GreenzoneImpl>>,

    /// A channel to notify the background thread of pending events to process. This is a
    /// SyncSender with bound 1, so only one notification can be pending at any given time.
    /// Notifiers must decide whether to ignore a pending notification or wait for it to clear.
    notify: mpsc::SyncSender<Notification>,
}

/// Notifications that can be sent from the emulation thread to the greenzone thread.
#[derive(Debug)]
enum Notification {
    /// The emulation thread has created work for the greewnzone thread, so the greenzone thread
    /// should wake up to handle it.
    Process,

    /// The emulation thread would like all pending events to be processed, so that the btrees are
    /// in a consistent and up-to-date state.
    Flush,
}

/// The data structures storing the state of the greenzone. This structure is shared by both the
/// emulation thread and the greenzone thread.
struct GreenzoneImpl {
    /// All full savestates stored in the greenzone, indexed by frame number.
    full_states: BTreeMap<u32, Savestate>,
    /// All delta savestates stored in the greenzone, indexed by frame number.
    delta_states: BTreeMap<u32, DeltaSavestate>,

    /// The total amount of memory occupied by full savestates.
    full_memory_used: usize,
    /// The total amount of memory occupied by delta savestates.
    delta_memory_used: usize,

    /// The "mailbox" of pending operations for the greenzone thread to process.
    pending: VecDeque<Operation>,

    /// If true, the mailbox contains operations that are part of a garbage collection operation.
    /// Another garbage collection will not be attempted until these operations clear.
    gc_in_progress: bool,
}

/// A pending operation for the greenzone thread to process.
#[derive(Debug)]
enum Operation {
    /// Insert a full savestate.
    Save(u32, Savestate),

    /// Delta-compress a full savestate.
    DeltaCompress { frame: u32, parent: u32 },

    /// Recompress a delta savestate with a new parent.
    Reparent { frame: u32, new_parent: u32 },

    /// Invalidate all states after a point in time.
    Invalidate { after: u32 },

    /// No operation. A placeholder for operations in the queue that have been made redundant.
    Nop,

    /// Set the `gc_in_progress` flag to false. Added to the queue at the end of the garbage
    /// collection process.
    GcFinished,
}

impl Operation {
    /// Returns true if this operation makes the given preceding operation redundant.
    ///
    /// For example, if the emulator writes twice to the same frame,
    /// the second write would invalidate the first.
    fn invalidates(&self, other: &Operation) -> bool {
        match (self, other) {
            // No-ops are always considered invalid.
            (_, Self::Nop) => true,

            // A Save operation overwrites delta compression and save operations.
            (
                Self::Save(f1, _),
                Self::Save(f2, _)
                | Self::DeltaCompress { frame: f2, .. }
                | Self::Reparent { frame: f2, .. },
            ) => f1 == f2,

            // Invalidate operations invalidate everything that happens afterwards, obviously.
            (
                Self::Invalidate { after },
                Self::Save(frame, _)
                | Self::DeltaCompress { frame, .. }
                | Self::Reparent { frame, .. },
            ) => frame > after,

            // Invalidate operations are never invalidated.
            (_, Self::Invalidate { .. }) => false,

            // Delta-compress and reparent operations don't invalidate anything.
            (Self::DeltaCompress { .. } | Self::Reparent { .. }, _) => false,

            (Self::Nop, _) => false,
            (Self::GcFinished, _) | (_, Self::GcFinished) => false,
        }
    }
}

impl Greenzone {
    /// Creates a new greenzone starting from the given power-on state.
    pub fn new(frame_0: Savestate) -> Greenzone {
        let (send, recv) = mpsc::sync_channel(1);
        let g = Arc::new(Mutex::new(GreenzoneImpl {
            full_memory_used: frame_0.size(),
            delta_memory_used: 0,
            full_states: [(0, frame_0)].into_iter().collect(),
            delta_states: BTreeMap::new(),
            pending: VecDeque::new(),
            gc_in_progress: false,
        }));
        let g_ = g.clone();
        std::thread::Builder::new()
            .name("Greenzone Worker Thread".to_string())
            .spawn(|| Self::background_thread(g_, recv))
            .unwrap();
        Greenzone { g, notify: send }
    }

    fn memory_threshold(&self) -> usize {
        500_000_000
    }

    /// Invalidates all states after the given frame.
    pub fn invalidate(&mut self, after: u32) {
        self.push(Operation::Invalidate { after })
    }

    /// Inserts a frame in the greenzone
    pub fn save(&mut self, frame: u32, state: Savestate) {
        self.push(Operation::Save(frame, state))
    }

    /// Returns true if the greenzone contains a state on the given frame.
    pub fn contains(&self, frame: u32) -> bool {
        let g = self.g.lock().unwrap();
        // Check the btrees first.
        let mut valid = g.full_states.contains_key(&frame) || g.delta_states.contains_key(&frame);

        // Check the mailbox to see if any pending operations change the result.
        for operation in &g.pending {
            match operation {
                Operation::Save(f, _) => {
                    if *f == frame {
                        valid = true
                    }
                }
                Operation::Invalidate { after } => {
                    if frame > *after {
                        valid = false
                    }
                }
                _ => {}
            }
        }

        valid
    }

    /// Return the most recent state at or before the given frame.
    pub fn restore(&self, frame: u32) -> (u32, SavestateRef) {
        let g = self.g.lock().unwrap();

        // Search for the most recent full state in the btree.
        let mut full = g
            .full_states
            .range(0..=frame)
            .next_back()
            .expect("should always have a power-on state");

        // Search for the most recent delta savestate in the btree.
        let mut delta = g.delta_states.range(*full.0..=frame).next_back();

        // Scan pending operations to find a better savestate, if any.
        let mut latest_pending: Option<(u32, &Savestate)> = None;

        for operation in &g.pending {
            match operation {
                Operation::Save(f, s) => {
                    if *f <= frame && *f >= latest_pending.map(|l| l.0).unwrap_or(0) {
                        latest_pending = Some((*f, s))
                    }
                }
                Operation::DeltaCompress { .. } | Operation::Reparent { .. } => {
                    // We can safely ignore unapplied delta-compression operations, because they do
                    // not change contents of the savestates, only how they are stored.
                }
                Operation::Invalidate { after } => {
                    if *after >= frame {
                        continue;
                    }

                    assert!(latest_pending.is_none() || *after >= latest_pending.unwrap().0);

                    if full.0 > after {
                        // Our full savestate has been invalidated. Find a new one.
                        full = g
                            .full_states
                            .range(0..=*after)
                            .next_back()
                            .expect("should always have a power-on state");
                    }
                    if delta.is_some_and(|d| d.0 > after) {
                        // Our delta savestate has been invalidated. Find a new one.
                        delta = g.delta_states.range(*full.0..=*after).next_back();
                    }
                }
                Operation::Nop | Operation::GcFinished => {}
            }
        }

        // At this point, `full` and `delta` contain the latest candidate savestates from the btree
        // that have not been invalidated by pending operations. latest_pending contains the latest
        // savestate that has been added by pending operations.

        if let Some(pending) = latest_pending {
            if pending.0 >= *delta.map(|d| d.0).unwrap_or(full.0) {
                // We have a pending state that is better than anything in the btree.
                return (pending.0, SavestateRef::Full(pending.1.clone()));
            }
        }

        if let Some(delta) = delta {
            (*delta.0, SavestateRef::Delta(delta.1.clone()))
        } else {
            (*full.0, SavestateRef::Full(full.1.clone()))
        }
    }

    /// If memory usage is above memory_threshold, removes/delta-compresses savestates
    /// so that total memory usage is below 3/4 * memory_threshold.
    /// The cursor frame is used to help determine priority: frames nearer to this point are less
    /// likely to be pruned.
    pub fn gc(&mut self, cursor_frame: u32) {
        let mut lock = self.g.lock().unwrap();
        let mut g = &mut *lock;

        // Helper function to computes the priority of a given frame.
        // The priority is determined by the distance to the cursor shifted right by the number of
        // trailing zero bits in the frame number, with lower values indicating higher priority. So
        // near the cursor every frame will be kept, but as you get farther away only even frames,
        // then only every fourth frame, then only every eigth frame, etc.
        let priority = |frame| {
            cursor_frame
                .abs_diff(frame)
                .checked_shr(frame.trailing_zeros())
                .unwrap_or(0)
        };

        // Helper function to compute the base-2 logarithm of priority.
        let log_priority = |frame| priority(frame).checked_ilog2().unwrap_or(0) as usize;

        if g.full_memory_used + g.delta_memory_used > self.memory_threshold() && !g.gc_in_progress {
            g.gc_in_progress = true;
            //  Handle all pending operations first, so the btree is fully consistent.
            std::mem::drop(lock);
            self.notify.send(Notification::Flush).unwrap();
            // Flush a second time, to wait for the first to complete.
            self.notify.send(Notification::Flush).unwrap();
            lock = self.g.lock().unwrap();
            g = &mut *lock;
            assert!(g.pending.is_empty());

            // Sanity check: make sure we don't have any orphaned delta states
            let mut full_states = g.full_states.iter().peekable();
            let mut full = full_states
                .next()
                .expect("guaranteed to have a power-on state")
                .1;
            for (frame, state) in &g.delta_states {
                while full_states.peek().is_some_and(|(f, _)| *f < frame) {
                    full = full_states.next().unwrap().1;
                }
                assert!(state.parent_is(full));
            }

            // The target amount of memory for full states
            let full_threshold = self.memory_threshold() / 4;
            let delta_threshold = self.memory_threshold() / 2;

            // Find a priority threshold above which frames will get deleted,
            // by building a histogram of memory usage.
            let mut full_histogram = [0usize; 32];
            for (frame, state) in &g.full_states {
                full_histogram[log_priority(*frame)] += state.size();
            }
            full_histogram
                .iter_mut()
                .scan(0, |total, s| {
                    *s += *total;
                    *total = *s;
                    Some(())
                })
                .for_each(std::mem::drop);
            assert_eq!(*full_histogram.last().unwrap(), g.full_memory_used);

            // Find full savestates that should be downgraded to delta savestates.
            let frames_to_downgrade = g
                .full_states
                .keys()
                .copied()
                .filter(|frame| {
                    *frame != 0 && full_histogram[log_priority(*frame)] >= full_threshold
                })
                .collect::<Vec<_>>();

            for frame in frames_to_downgrade {
                let (parent_frame, _) = g
                    .full_states
                    .range(0..frame)
                    .filter(|(&frame, _)| {
                        frame == 0 || full_histogram[log_priority(frame)] < full_threshold
                    })
                    .last()
                    .expect(
                        "will always have a parent because frame 0 is guaranteed to be present",
                    );
                let next_frame = g.full_states.range((frame + 1)..).map(|(&k, _v)| k).next();

                // We need to reparent any delta states who were depending on this state.
                for (delta_frame, _) in g
                    .delta_states
                    .range_mut(frame..next_frame.unwrap_or(u32::MAX))
                {
                    g.pending.push_back(Operation::Reparent {
                        frame: *delta_frame,
                        new_parent: *parent_frame,
                    })
                }

                g.pending.push_back(Operation::DeltaCompress {
                    frame,
                    parent: *parent_frame,
                });
            }

            // Now find delta frames that should be removed.
            // (Note that this only checks delta savestates that existed before downgrading full
            // savestates, since the pending DeltaCompress operations have not been processed yet.)
            let mut delta_histogram = [0usize; 32];
            for (frame, state) in &g.delta_states {
                delta_histogram[log_priority(*frame)] += state.size();
            }

            delta_histogram
                .iter_mut()
                .scan(0, |total, s| {
                    *s += *total;
                    *total = *s;
                    Some(())
                })
                .for_each(std::mem::drop);
            assert_eq!(*delta_histogram.last().unwrap(), g.delta_memory_used);

            g.delta_states.retain(|frame, state| {
                if delta_histogram[log_priority(*frame)] < delta_threshold {
                    true
                } else {
                    g.delta_memory_used -= state.size();
                    false
                }
            });

            // Push a GcFinished operation so that the gc_in_progress flag will be reset once the
            // pending operations generated by garbage collection have cleared.
            g.pending.push_back(Operation::GcFinished);

            // Wake up the greenzone thread to start processing these operations.
            _ = self.notify.try_send(Notification::Process);
        }
    }

    /// Enqueues an operation in the background thread's mailbox.
    fn push(&mut self, operation: Operation) {
        let mut g = self.g.lock().unwrap();
        // See if this operation makes anything currently in the queue redundant.
        while let Some(front) = g.pending.front() {
            // If it invalidates the operation in the front of the queue, pop it.
            if operation.invalidates(front) {
                g.pending.pop_front();
            } else {
                break;
            }
        }

        // If it invalidates an operation in the middle of the queue, replace it with a no-op.
        for op in &mut g.pending {
            if operation.invalidates(op) {
                *op = Operation::Nop
            }
        }

        // Push the operation to the back of the queue.
        g.pending.push_back(operation);

        // Wake the background thread (if there's already a notification pending, no need).
        _ = self.notify.try_send(Notification::Process);
    }

    /// Greenzone thread main loop
    fn background_thread(g_: Arc<Mutex<GreenzoneImpl>>, recv: mpsc::Receiver<Notification>) {
        loop {
            match recv.recv() {
                // If we receive a process notification, process until the queue size is below 100.
                Ok(Notification::Process) => Self::process_pending(&g_, 100),

                // If we receive a flush notification, clear the queue.
                Ok(Notification::Flush) => Self::process_pending(&g_, 0),

                // If the emulation thread disconnects from the channel, terminate.
                Err(mpsc::RecvError) => break,
            };
        }
    }

    fn process_pending(g_: &Arc<Mutex<GreenzoneImpl>>, threshold: usize) {
        let mut lock = g_.lock().unwrap();
        let mut g = &mut *lock;

        while g.pending.len() > threshold {
            match g.pending.pop_front().unwrap() {
                Operation::Save(frame, state) => {
                    g.full_memory_used += state.size();

                    // Remove an old delta frame, if there was one.
                    if let Some(old) = g.delta_states.remove(&frame) {
                        g.delta_memory_used -= old.size();
                    }

                    // Reparent any delta savestates which should now reference this savestate.
                    let next_frame = g.full_states.range(frame + 1..).next().map(|(k, _v)| *k);
                    for (f, _) in g
                        .delta_states
                        .range_mut(frame..next_frame.unwrap_or(u32::MAX))
                    {
                        /*
                        g.delta_memory_used -= delta.size();
                        delta.reparent(old_parent, &state);
                        g.delta_memory_used += delta.size();*/
                        // Reparent this state, unless the state's been overwritten.
                        if g.pending.iter().all(|op| match op {
                            Operation::Save(frame, _) => frame != f,
                            Operation::Invalidate { after } => frame <= *after,
                            _ => true,
                        }) {
                            g.pending.push_back(Operation::Reparent {
                                frame: *f,
                                new_parent: frame,
                            })
                        }
                    }

                    // Remove an old frame, if there was one.
                    if let Some(old) = g.full_states.insert(frame, state) {
                        g.full_memory_used -= old.size();
                    }
                }
                Operation::DeltaCompress { frame, parent } => {
                    let state = g.full_states.remove(&frame).unwrap();
                    let parent = g.full_states.get(&parent).unwrap().clone();

                    // Unlock the greenzone while we're compressing. This way, the emulator can
                    // continue to run while we do long-running compression operations in the
                    // background.
                    std::mem::drop(lock);
                    // NOTE: at this point, the greenzone is technically in an inconsistent state sa
                    // the DeltaCompress operation has been removed from the queue without being
                    // applied to the btree! However, this does not cause correctness issues as
                    // nobody besides us cares that this state should be delta-compressed.
                    let delta = state.to_delta(&parent);
                    lock = g_.lock().unwrap();
                    g = &mut *lock;

                    g.full_memory_used -= state.size();
                    g.delta_memory_used += delta.size();

                    assert!(g.delta_states.insert(frame, delta).is_none());
                }
                Operation::Reparent {
                    frame, new_parent, ..
                } => {
                    let mut delta = g.delta_states.get_mut(&frame).unwrap().clone();
                    let new_parent = g.full_states.get(&new_parent).unwrap().clone();
                    g.delta_memory_used -= delta.size();

                    // Unlock the greenzone while we're compressing. This way, the emulator can
                    // continue to run while we do long-running compression operations in the
                    // background.
                    std::mem::drop(lock);
                    // NOTE: See above note about greenzone consistency. This could cause
                    // correctness issues if someone is expecting delta savestates to have the
                    // correct parents, but nobody relies on that as a delta savestate stores a
                    // reference to its parent..
                    delta.reparent(&new_parent);
                    lock = g_.lock().unwrap();
                    g = &mut *lock;

                    g.delta_memory_used += delta.size();
                    g.delta_states.insert(frame, delta);
                }
                Operation::Invalidate { after } => {
                    g.full_states.retain(|f, s| {
                        if *f <= after {
                            true
                        } else {
                            g.full_memory_used -= s.size();
                            false
                        }
                    });
                    g.delta_states.retain(|f, s| {
                        if *f <= after {
                            true
                        } else {
                            g.delta_memory_used -= s.size();
                            false
                        }
                    });
                }
                Operation::Nop => {}
                Operation::GcFinished => g.gc_in_progress = false,
            }
        }
    }
}
